<!DOCTYPE html>
<html lang="en">
<head>
    <title>gpu-physics.js by schteppe adapted to cellPACK</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <meta name="twitter:creator" content="@schteppe&@ludo" />
    <meta property="og:title" content="gpu-physics.js by schteppe adapted to cellPACK" />
    <meta property="og:description" content="Play around with a massive amount of rigid bodies in this demo." />
    <meta property="og:url" content="https://schteppe.github.io/gpu-physics.js/" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://schteppe.github.io/gpu-physics.js/gpu-physics.jpg" />

    <style>
        body {
            color: #000000;
            font-family: "Lucida Grande", sans-serif;
            font-size: 12px;
            font-weight: normal;
            text-align: center;
            background-color: #000000;
            margin: 0px;
            overflow: hidden;
        }

        #info {
            position: absolute;
            bottom: 0px;
            width: 100%;
            padding: 5px;
        }

        a {
            color: #000000;
            font-weight: bold;
            text-decoration: none;
        }
    </style>
</head>
<body>

<div id="container"></div>
<div id="info">
    <b>gpu physics adapted to cellPACK</b> by <a href="http://twitter.com/schteppe">@schteppe</a> and @ludo
</div>

<script id="sharedShaderCode" type="x-shader/x-fragment">
// Convert an index to an UV-coordinate
vec2 indexToUV(float index, vec2 res){
    vec2 uv = vec2(mod(index/res.x,1.0), floor( index/res.y ) / res.x);
    return uv;
}

// Rotate a vector by a quaternion
vec3 vec3_applyQuat(vec3 v, vec4 q){
    float ix =  q.w * v.x + q.y * v.z - q.z * v.y;
    float iy =  q.w * v.y + q.z * v.x - q.x * v.z;
    float iz =  q.w * v.z + q.x * v.y - q.y * v.x;
    float iw = -q.x * v.x - q.y * v.y - q.z * v.z;

    return vec3(
        ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y,
        iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z,
        iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x
    );
}
</script>

<!--
    Render body instances vertex shader
    Copy of THREE.ShaderLib.phong + modifications to render instances
-->
<script id="renderBodiesVertex" type="x-shader/x-vertex">
uniform sampler2D bodyPosTex;
uniform sampler2D bodyQuatTex;
attribute float bodyIndex;
attribute vec3 bodyColor;
#define PHONG
varying vec3 vViewPosition;
//varying vec3 vColor;
varying vec3 vNormal;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
    #include <uv_vertex>
    #include <uv2_vertex>
    #include <color_vertex>
    vec2 bodyUV = indexToUV(bodyIndex,bodyTextureResolution);
#ifdef USE_COLOR
    //vColor = vec3((floor(bodyUV*3.0)+1.0)/3.0,0);
    vColor = vec3(bodyColor);
#endif

    //vColor = vec3(1,0,0);
    #include <beginnormal_vertex>
    #include <morphnormal_vertex>
    #include <skinbase_vertex>
    #include <skinnormal_vertex>
    vec3 bodyPos = texture2D(bodyPosTex,bodyUV).xyz;
    vec4 bodyQuat = texture2D(bodyQuatTex,bodyUV).xyzw;
    objectNormal.xyz = vec3_applyQuat(objectNormal.xyz, bodyQuat);
    #include <defaultnormal_vertex>
#ifndef FLAT_SHADED
    vNormal = normalize( transformedNormal );
#endif
    #include <begin_vertex>
    transformed.xyz = vec3_applyQuat(transformed.xyz, bodyQuat);
    transformed.xyz += bodyPos;
    #include <displacementmap_vertex>
    #include <morphtarget_vertex>
    #include <skinning_vertex>
    #include <project_vertex>
    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>
    vViewPosition = - mvPosition.xyz;
    #include <worldpos_vertex>
    #include <envmap_vertex>
    #include <shadowmap_vertex>
    #include <fog_vertex>
}
</script>

<!--
    Render body instances vertex shader
    Copy of THREE.ShaderLib.phong + modifications to render body instances with correct transform
-->
<script id="renderParticlesVertex" type="x-shader/x-vertex">
uniform sampler2D particleWorldPosTex;
uniform sampler2D quatTex;
attribute float particleIndex;
#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
    varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
    #include <uv_vertex>
    #include <uv2_vertex>
    #include <color_vertex>
    vec2 particleUV = indexToUV(particleIndex,resolution);
#ifdef USE_COLOR
    vColor = vec3((floor(particleUV*3.0)+1.0)/3.0,0);
#endif
    #include <beginnormal_vertex>
    #include <morphnormal_vertex>
    #include <skinbase_vertex>
    #include <skinnormal_vertex>
    vec4 particlePosAndBodyId = texture2D(particleWorldPosTex,particleUV);
    vec2 bodyUV = indexToUV(particlePosAndBodyId.w,bodyTextureResolution);
    vec4 bodyQuat = texture2D(quatTex,bodyUV).xyzw;
    objectNormal.xyz = vec3_applyQuat(objectNormal.xyz, bodyQuat);
#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
    vNormal = normalize( transformedNormal );
#endif
    #include <begin_vertex>
    vec3 particlePos = particlePosAndBodyId.xyz;
    transformed.xyz = vec3_applyQuat(transformed.xyz, bodyQuat);
    transformed.xyz += particlePos;
    #include <displacementmap_vertex>
    #include <morphtarget_vertex>
    #include <skinning_vertex>
    #include <project_vertex>
    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>
    vViewPosition = - mvPosition.xyz;
    #include <worldpos_vertex>
    #include <envmap_vertex>
    #include <shadowmap_vertex>
    #include <fog_vertex>
}
</script>

<!--
    Render depth. This is for rendering shadows.
-->
<script id="renderBodiesDepth" type="x-shader/x-vertex">
uniform sampler2D bodyPosTex;
uniform sampler2D bodyQuatTex;
attribute float bodyIndex;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#include <begin_vertex>

    vec2 bodyUV = indexToUV(bodyIndex,bodyTextureResolution);
    vec3 bodyPos = texture2D(bodyPosTex,bodyUV).xyz;
    vec4 bodyQuat = texture2D(bodyQuatTex,bodyUV).xyzw;
    transformed.xyz = vec3_applyQuat(transformed.xyz, bodyQuat);
    transformed.xyz += bodyPos;

	#include <displacementmap_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
}
</script>

<script id="cv_vertexShader" type="x-shader/x-vertex">
  uniform float scale;
  uniform sampler2D bodyPosTex;
  uniform sampler2D bodyQuatTex;
  uniform sampler2D atomPositionsTex;//xyz,1
  //uniform sampler2D bodyInfoTex;//start,count for eveyt type

  // = camera.projectionMatrix
  uniform mat4 projectionMatrix;

  // = camera.matrixWorldInverse
  uniform mat4 viewMatrix;

  attribute vec2 instanceInfos;//for every bead?

  attribute vec2 _TriUVs;
  attribute float  _TriIndices;
  attribute vec3 _TriVertices;
  attribute float gl_VertexID;

	varying vec3 vPosition;
	varying vec4 vColor;
  varying float radius;
  varying vec3 vPosition;
  varying vec2 uv;

	void main(){
    int vertexId = (int) gl_VertexID;
    int particleId = (int) instanceInfos.x;
    int instanceId = (int) instanceInfos.y;

    vec2 bodyUV = indexToUV(instanceId,bodyTextureResolution);
    vec4 bodyQuat = texture2D(bodyQuatTex,bodyUV).xyzw;
    vec2 start_count = texture2D(bodyInfoTex,nodeUV).xy;
    vec4 sphere = texture2D(bodyPosTex,bodyUV).xyzw;

    vec2 atomUV = indexToUV(particleId,bodyTextureResolution);

    vec4 spherePosition = texture2D(atomPositionsTex,atomUV).xyzw * scale;//(lodLevel == 0) ? _ProteinAtomPositions[sphereBatchInfo.w + vertexId / 3] : _ProteinClusterPositions[sphereBatchInfo.w + vertexId / 3];
    radius = sphere.w;
    vec3 vertexPos = _TriVertices * scale * radius;
    vec3 billboardWorldPos = pos + vec3_applyQuat(spherePosition.xyz, bodyQuat) * scale;// _InstancePositions[instanceId].xyz;
    vec4 billboardVertexWorldPos = vec4(billboardWorldPos, 0)
              + _CameraRight * vertexPos.x + _CameraUp * vertexPos.y;
    billboardVertexWorldPos = vec4(billboardWorldPos, 0) + viewMatrix * float4(vertexPos,0);
		vPosition = billboardVertexWorldPos.xyz;
    uv = _TriUVs;
    gl_Position =  projectionMatrix * vec4( vPosition, 1.0 );
	}

</script>

<script id="cv_fragmentShader" type="x-shader/x-fragment">
	varying vec4 vColor;
  varying float radius;
  varying vec3 vPosition;
  varying vec2 uv;
  //depth buffer?
	void main() {
    //float lensqr = dot(uv, uv);
    //if (lensqr > 1) discard;
    //if (radius == 0) discard;
    //vec3 normal = normalize(vec3(uv, sqrt(1.0 - lensqr)));
    // Find depth
		//float eyeDepth = LinearEyeDepth(input.vertex.z) + input.radius * (1 - normal.z);
		//float depth = 1 / (eyeDepth * _ZBufferParams.z) - _ZBufferParams.w / _ZBufferParams.z;
		gl_FragColor = vec4(1,0,0,1);//normal,1);
	}
</script>
<!-- NGL  -->
<script src="https://cdn.rawgit.com/arose/ngl/v2.0.0-dev.24/dist/ngl.js"></script>
<script src="js/util.js"></script>

<script src="js/query_helper.js"></script>
<script src="js/cp_serialized.js"></script>
<script src="js/ngl.js"></script>
<script src="extras/d3.v4.min.js"></script>
<script src="extras/gpuphysics/lib/three.min.js"></script>
<script src="extras/gpuphysics/lib/stats.min.js"></script>
<script src="extras/gpuphysics/lib/dat.gui.min.js"></script>
<script src="extras/gpuphysics/lib/three.orbitcontrols.js"></script>
<script src="extras/gpuphysics/lib/three.transformcontrols.js"></script>
<script src="extras/shaderToon.js"></script>

<!-- NGL  -->
<script src="https://cdn.rawgit.com/arose/ngl/v2.0.0-dev.24/dist/ngl.js"></script>
<script src="extras/gpuphysics/build/gp.js"></script>
<script src="extras/gpuphysics/main_physics.js"></script>
</body>
</html>
